#import "../tools.typ": *
= Introduction
This project presents two solutions for the Travelling Salesman Problem (TSP), utilizing two distinct approaches:

+ *Mathematical Model*: This approach employs the CPLEX C API's to formulate and solve the TSP as an optimization problem.

+ *Heuristic Model*: This approach uses the Simulated Annealing algorithm to find an approximate solution to the TSP.

Both methods aim to minimize the total travel distance while visiting each point exactly once and returning to the starting point. The mathematical model guarantees an optimal solution, whereas the heuristic model provides a near-optimal solution in a shorter amount of time.
== Problem description
A company produces boards with holes used to build electric panels. Boards
are positioned over a machine and a drill moves over the board, stops at the desired
positions and makes the holes. Once a board is drilled, a new board is positioned and
the process is iterated many times. Given the position of the holes on the board, the
company asks us to determine the hole sequence that minimizes the total drilling time,
taking into account that the time needed for making an hole is the same and constant for
all the holes.

== Project structure
The project is organized in the #code("TSP-solver", lan:"none") folder as shown in #fig("structure", "Figure 1").
- #code("data/", lan: "none") : it contains the datasets generated by the script #code("data_generator.py"). In the subfolder #code("sol/", lan: none) it stores all the path solutions for each dataset.

- #code("plots/", lan: none) : it contains the plots generated by the script #code("data_generator.py"). In the subfolder #code("sol/", lan: none) it stores all the plots with their path solution.

- #code("report.pdf") : the written report of the project.

- #code("scripts/", lan: none) : it contains the python script used to generate and plot data. They are explained in section #fig("instances-gen", "2. Instances generator").
- #code("src/", lan: none) : it contains the source files of the c++ project:

  - #code("main.cpp") : the main file of the project. It runs the CplexSolver and SASolver on two datasets.

  - #code("makefile") : the makefile used to compile the project.

  - #code("CplexSolver.cpp/.h", lan:none) : a TSP solver which uses the CPLEX C API's. It implements the abstract class #code("TSPSolver") . It is explained in section #fig("cplex", "Part I: Cplex Solver").
  - #code("cpxmacro.h") : useful macros of the CPLEX C API's.
  - #code("Point.cpp/.h", lan: none) : a class representing a single point.

  - #code("SASolver.cpp/.h", lan: none) : a TSP solver which uses the Simulated Annealing algorith. It implements the abstract class #code("TSPSolver") . It is explained in section #fig("simulated-annealing", "Part II: Simulated Annealing").

  - #code("TSP.cpp/.h", lan: none) : a TSP representation of the problem. It loads points from a dataset and calculates the matrix costs.

  - #code("TSPSolution.cpp/.h", lan: none) : a representation of a path solution to a TSP problem.

  - #code("TSPSolver.cpp/.h", lan:none) : an abstract class representing a solver for the TSP.

<structure>
#align(center, figure(block(align(left, raw("TSP-solver/
├── data/
│   ├── sol/
│   │   ├── Path_TSP_10_1.dat
│   │   └── ...
│   ├── TSP_10_1.dat
│   └── ...
├── plots/
│   ├── sol/
│   │   ├── Path_TSP_10_1.png
│   │   └── ...
│   ├── TSP_10_1.png
│   └── ...
├── report.pdf
├── scripts/
│   ├── data_generator.py
│   └── plot_solutions.py
└── src/
    ├── main.cpp
    ├── makefile
    ├── CplexSolver.cpp
    ├── CplexSolver.h
    ├── cpxmacro.h
    ├── point.cpp
    ├── point.h
    ├── SASolver.cpp
    ├── SASolver.h
    ├── TSP.cpp
    ├── TSP.h
    ├── TSPSolution.cpp
    ├── TSPSolution.h
    ├── TSPSolver.cpp
    └── TSPSolver.h
")
)), caption: [Project structure], kind: {image}))


== Compilation
The project is written in C++ and compiles using the makefile provided in the #code("src") folder. To compile the project, use the command #code("make") in the #code("src/", lan: "raw") folder. The makefile compiles the project using the #code("g++", lan: "raw") compiler and produces an executable named #code("main"). 
The project uses the C++11 standard, so it is necessary to use a compiler that supports this standard.

It is possible to clean the project using the command #code("make clean", lan: "raw"). This command removes the executable and all the object files.

The python scripts provided in the #code("scripts") folder and used to generate and plot data can be run using the command #code("python3 script_name.py"). The scripts require the #code("matplotlib") and #code("numpy") libraries to be installed. The libraries can be easily installed using the command #code("pip install matplotlib") and #code("pip install numpy").

Note that any re run of the scripts will overwrite the existing data and plots. Since the data is generated randomly, the results may vary between runs.

All the tests have been made on the LabTA calculators from remote, on Ubuntu Operative System.


#pagebreak()